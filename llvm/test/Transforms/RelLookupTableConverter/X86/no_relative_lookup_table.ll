; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -passes=rel-lookup-table-converter -mtriple=x86_64-linux -S | FileCheck %s
; RUN: opt < %s -passes=rel-lookup-table-converter -mtriple=i386-unknown-unknown -relocation-model=pic -S | FileCheck %s
; RUN: opt < %s -passes=rel-lookup-table-converter -mtriple=x86_64-linux -relocation-model=pic -code-model=medium -S | FileCheck %s
; RUN: opt < %s -passes=rel-lookup-table-converter -mtriple=x86_64-linux -relocation-model=pic -code-model=large -S | FileCheck %s
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"

@.str = private unnamed_addr constant [5 x i8] c"zero\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"one\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"two\00", align 1
@.str.3 = private unnamed_addr constant [8 x i8] c"default\00", align 1

;; These globals structurally can be made PIC-friendly, but will not be
;; transformed because they have a use that could potentially escape the
;; visibility of this TU. If we want to transform a global, we must be able
;; to see all uses of it.
; CHECK-DAG: @escapes_through_call = internal constant [2 x ptr]
@escapes_through_call = internal constant [2 x ptr] [ ptr @.str, ptr @.str.1 ]

; CHECK-DAG: @escapes_through_ret = internal constant [2 x ptr]
@escapes_through_ret = internal constant [2 x ptr] [ ptr @.str, ptr @.str.1 ]

;; We allow usage through GEPs, but each GEP must only be used by a load.
; CHECK-DAG: @escapes_through_gep_call = internal constant [2 x ptr]
@escapes_through_gep_call = internal constant [2 x ptr] [ ptr @.str, ptr @.str.1 ]

@switch.table.string_table = private unnamed_addr constant [3 x ptr]
                             [
                              ptr @.str,
                              ptr @.str.1,
                              ptr @.str.2
                             ], align 8

; Switch lookup table
; CHECK: @switch.table.string_table = private unnamed_addr constant [3 x ptr]
; CHECK-SAME: [
; CHECK-SAME: ptr @.str,
; CHECK-SAME: ptr @.str.1,
; CHECK-SAME: ptr @.str.2
; CHECK-SAME: ], align 8

; ; Relative switch lookup table for strings
define ptr @string_table(i32 %cond) {
  ; CHECK-LABEL: @string_table(
  ; CHECK-NEXT:  entry:
  ; CHECK-NEXT:    [[TMP0:%.*]] = icmp ult i32 [[COND:%.*]], 3
  ; CHECK-NEXT:    br i1 [[TMP0]], label [[SWITCH_LOOKUP:%.*]], label [[RETURN:%.*]]
  ; CHECK:       switch.lookup:
  ; CHECK-NEXT:    [[SWITCH_GEP:%.*]] = getelementptr inbounds [3 x ptr], ptr @switch.table.string_table, i32 0, i32 [[COND]]
  ; CHECK-NEXT:    [[SWITCH_LOAD:%.*]] = load ptr, ptr [[SWITCH_GEP]], align 8
  ; CHECK-NEXT:    ret ptr [[SWITCH_LOAD]]
  ; CHECK:       return:
  ; CHECK-NEXT:    ret ptr @.str.3

entry:
  %0 = icmp ult i32 %cond, 3
  br i1 %0, label %switch.lookup, label %return

switch.lookup:                                    ; preds = %entry
  %switch.gep = getelementptr inbounds [3 x ptr], ptr @switch.table.string_table, i32 0, i32 %cond
  %switch.load = load ptr, ptr %switch.gep, align 8
  ret ptr %switch.load

return:                                           ; preds = %entry
  ret ptr @.str.3
}


declare void @extern_func(ptr %p)

define ptr @global_escapes_through_call(i32 %x) {
entry:
; CHECK-LABEL: @global_escapes_through_call
; CHECK:       entry:
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [2 x ptr], ptr @escapes_through_call, i32 0, i32 %x
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[GEP]], align 8
; CHECK-NEXT:    call void @extern_func(ptr @escapes_through_call)
; CHECK-NEXT:    ret ptr [[LOAD]]
  %0 = getelementptr [2 x ptr], ptr @escapes_through_call, i32 0, i32 %x
  %1 = load ptr, ptr %0
  call void @extern_func(ptr @escapes_through_call)
  ret ptr %1
}

define ptr @global_escapes_through_ret(i32 %x) {
entry:
; CHECK-LABEL: @global_escapes_through_ret
; CHECK:       entry:
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [2 x ptr], ptr @escapes_through_ret, i32 0, i32 %x
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[GEP]], align 8
; CHECK-NEXT:    ret ptr @escapes_through_ret
  %0 = getelementptr [2 x ptr], ptr @escapes_through_ret, i32 0, i32 %x
  %1 = load ptr, ptr %0
  ret ptr @escapes_through_ret
}

define ptr @global_escapes_through_gep_call(i32 %x) {
entry:
; CHECK-LABEL: @global_escapes_through_gep_call
; CHECK:       entry:
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr [2 x ptr], ptr @escapes_through_gep_call, i32 0, i32 %x
; CHECK-NEXT:    [[LOAD:%.*]] = load ptr, ptr [[GEP]], align 8
; CHECK-NEXT:    call void @extern_func(ptr [[GEP]])
; CHECK-NEXT:    ret ptr [[LOAD]]
  %0 = getelementptr [2 x ptr], ptr @escapes_through_gep_call, i32 0, i32 %x
  %1 = load ptr, ptr %0
  call void @extern_func(ptr %0)
  ret ptr %1
}
